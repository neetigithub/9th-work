# -*- coding: utf-8 -*-
"""Particle_Swarm_optimazation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/manan-arya/Major_Project/blob/Additional_Work/Particle_Swarm_optimazation.ipynb
"""

import pandas as pd
import numpy as np

! pip install pyswarms
import pyswarms as ps

data = pd.read_csv('after_ga.csv')

data

data.shape[1]-1

x_train = data.iloc[0:100,1:data.shape[1]-1].values
x_test = data.iloc[101:200,1:data.shape[1]-1].values

y_train = data.iloc[0:100,data.shape[1]-1].values
y_test = data.iloc[101:200,data.shape[1]-1].values

y_train = y_train.ravel()
y_test = y_test.ravel()

from sklearn.preprocessing import StandardScaler

sc_x = StandardScaler()
sc_y = StandardScaler()
x_tr = sc_x.fit_transform(x_train)
x_te = sc_x.fit_transform(x_test)
y_tr = sc_y.fit_transform(y_train.reshape(-1,1)).ravel()
y_te = sc_y.fit_transform(y_test.reshape(-1,1)).ravel()

x_tr.shape

y_tr.shape

! wget https://raw.githubusercontent.com/Sanbongawa/binary_swarm_intelligence/master/binary_optimization.py
# binary optimization library

import binary_optimization as opt

from sklearn import model_selection as ms
from sklearn import svm  
from tqdm import tqdm

class Evaluate:
    def __init__(self):
        self.train_label = y_tr
        self.train_data = x_tr
        self.test_label = y_te
        self.test_data = x_te
        self.K = 4
    def evaluate(self,gen):
        mask=np.array(gen) > 0
        al_data=np.array([al[mask] for al in self.train_data])
        al_test_data=np.array([al[mask] for al in self.test_data])
        kf = ms.KFold(n_splits=self.K)
        s = 0
        for tr_ix,te_ix in kf.split(al_data):
          clf = svm.SVR()
          clf = clf.fit(al_data[tr_ix],self.train_label[tr_ix])
          s+=clf.score(al_data[te_ix],self.train_label[te_ix])
            #s+= svm.LinearSVC().fit(al_data[tr_ix],self.train_label[tr_ix]).score(al_data[te_ix],self.train_label[te_ix])#.predict(al_test_data)
        s/=self.K
        return s#np.count_nonzero(self.test_l==res)/len(self.test_l)
    def check_dimentions(self,dim):
        if dim==None:
            return len(self.train_d[0])
        else:
            return dim

def test_score(gen,tr_x,tr_y,te_x,te_y):
    clf = svm.SVR()
    mask=np.array(gen) == 1
    al_data=np.array(x_tr[:,mask])
    al_test_data=np.array(x_te[:,mask])
    return np.mean([SVR.fit(al_data,y_tr).score(al_test_data,y_te) for i in range(4)])

s,g,l=opt.BPSO(Eval_Func=Evaluate,n=len(x_tr[0:]),m_i=200,dim = len(x_tr[0]) ,minf=0)

s # Score

l # no. of features selected

G = np.asarray(g) #masked array of selected features as 1's and 0's

G.shape



